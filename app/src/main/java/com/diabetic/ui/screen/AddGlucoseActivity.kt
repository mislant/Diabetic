package com.diabetic.ui.screenimport android.content.Intentimport android.os.Bundleimport android.util.Logimport android.widget.Toastimport androidx.activity.ComponentActivityimport androidx.activity.compose.setContentimport androidx.activity.enableEdgeToEdgeimport androidx.compose.foundation.backgroundimport androidx.compose.foundation.clickableimport androidx.compose.foundation.layout.Arrangementimport androidx.compose.foundation.layout.Columnimport androidx.compose.foundation.layout.Rowimport androidx.compose.foundation.layout.Spacerimport androidx.compose.foundation.layout.fillMaxSizeimport androidx.compose.foundation.layout.paddingimport androidx.compose.foundation.layout.sizeimport androidx.compose.foundation.layout.widthimport androidx.compose.foundation.shape.RoundedCornerShapeimport androidx.compose.foundation.text.KeyboardOptionsimport androidx.compose.material.icons.Iconsimport androidx.compose.material.icons.filled.Bloodtypeimport androidx.compose.material.icons.filled.Scheduleimport androidx.compose.material3.AlertDialogimport androidx.compose.material3.DatePickerimport androidx.compose.material3.DatePickerDefaultsimport androidx.compose.material3.DatePickerDialogimport androidx.compose.material3.DisplayModeimport androidx.compose.material3.DropdownMenuItemimport androidx.compose.material3.ExperimentalMaterial3Apiimport androidx.compose.material3.ExposedDropdownMenuBoximport androidx.compose.material3.ExposedDropdownMenuDefaultsimport androidx.compose.material3.FilledTonalButtonimport androidx.compose.material3.Iconimport androidx.compose.material3.MaterialThemeimport androidx.compose.material3.OutlinedTextFieldimport androidx.compose.material3.OutlinedTextFieldDefaultsimport androidx.compose.material3.Textimport androidx.compose.material3.TextButtonimport androidx.compose.material3.TimePickerimport androidx.compose.material3.TimePickerDefaultsimport androidx.compose.material3.rememberDatePickerStateimport androidx.compose.material3.rememberTimePickerStateimport androidx.compose.runtime.Composableimport androidx.compose.runtime.collectAsStateimport androidx.compose.runtime.getValueimport androidx.compose.runtime.mutableStateOfimport androidx.compose.runtime.rememberimport androidx.compose.runtime.setValueimport androidx.compose.ui.Alignmentimport androidx.compose.ui.Modifierimport androidx.compose.ui.draw.clipimport androidx.compose.ui.platform.LocalContextimport androidx.compose.ui.text.input.KeyboardTypeimport androidx.compose.ui.tooling.preview.Previewimport androidx.compose.ui.unit.dpimport androidx.lifecycle.ViewModelimport androidx.lifecycle.ViewModelProviderimport androidx.lifecycle.viewmodel.compose.viewModelimport com.diabetic.application.command.AddGlucoseLevelimport com.diabetic.domain.model.GlucoseLevelimport com.diabetic.infrastructure.persistent.stub.StubGlucoseLevelRepositoryimport com.diabetic.ui.ServiceLocatorimport com.diabetic.ui.screen.component.DiabeticLayoutimport com.diabetic.ui.theme.DiabeticMaterialThemeimport kotlinx.coroutines.flow.MutableStateFlowimport kotlinx.coroutines.flow.asStateFlowimport java.time.Instantimport java.time.LocalDateimport java.time.LocalDateTimeimport java.time.ZoneIdimport java.time.format.DateTimeFormatterclass AddGlucoseActivity : ComponentActivity() {    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        enableEdgeToEdge()        setContent {            val model = viewModel<AddGlucoseViewModel>(                factory = AddGlucoseViewModel.Factory            )            Content(model)        }    }}@Composableprivate fun Content(model: AddGlucoseViewModel) {    val state = model.state.collectAsState()    DiabeticMaterialTheme {        if (state.value.error.isNotEmpty()) {            Toast                .makeText(                    LocalContext.current,                    state.value.error,                    Toast.LENGTH_LONG                )                .show()            model.flushError()        }        DiabeticLayout { innerPadding ->            Column(                modifier = Modifier                    .padding(innerPadding)                    .fillMaxSize(),                verticalArrangement = Arrangement.Center,                horizontalAlignment = Alignment.CenterHorizontally            ) {                AddGlucoseLevelForm(                    state = state.value,                    onGlucoseLevelChange = model::changeGlucoseLevel,                    onMeasureTypeChange = model::changeMeasureType,                    onDateChange = model::changeDate,                    onTimeChange = model::changeTime,                    saveGlucoseLevel = model::addLevel                )            }        }    }}@Composableprivate fun AddGlucoseLevelForm(    state: AddGlucoseViewModelState,    onGlucoseLevelChange: (String) -> Unit,    onMeasureTypeChange: (GlucoseLevel.MeasureType) -> Unit,    onDateChange: (Long?) -> Unit,    onTimeChange: (hour: Int, minute: Int) -> Unit,    saveGlucoseLevel: () -> Boolean) {    OutlinedTextField(        value = state.glucoseLevel,        singleLine = true,        onValueChange = onGlucoseLevelChange,        leadingIcon = {            Icon(                imageVector = Icons.Default.Bloodtype,                contentDescription = null            )        },        keyboardOptions = KeyboardOptions.Default.copy(            keyboardType = KeyboardType.Decimal        ),        placeholder = { Text(text = "Уровень глюкозы") },        label = { Text(text = "Уровень глюкозы") },    )    Spacer(modifier = Modifier.size(20.dp))    MeasureTypeDropDown(        state = state,        onMeasureTypeChange = onMeasureTypeChange    )    Spacer(modifier = Modifier.size(20.dp))    DateTimePicker(onDateChange, onTimeChange)    Spacer(modifier = Modifier.size(20.dp))    val ctx = LocalContext.current    FilledTonalButton(onClick = {        saveGlucoseLevel().onSuccess {            Intent(ctx, MainActivity::class.java).also {                ctx.startActivity(it)            }        }    }) {        Text(text = "Добавить")    }}private fun Boolean.onSuccess(block: () -> Unit) {    if (this) {        block()    }}@OptIn(ExperimentalMaterial3Api::class)@Composableprivate fun MeasureTypeDropDown(    state: AddGlucoseViewModelState,    onMeasureTypeChange: (GlucoseLevel.MeasureType) -> Unit) {    var isExpanded by remember {        mutableStateOf(false)    }    ExposedDropdownMenuBox(        expanded = isExpanded,        onExpandedChange = { isExpanded = it }    ) {        OutlinedTextField(            value = when (state.measureType) {                GlucoseLevel.MeasureType.AFTER_MEAL -> "После еды"                GlucoseLevel.MeasureType.BEFORE_MEAL -> "До еды"                GlucoseLevel.MeasureType.UNSPECIFIED -> "Не указан"            },            onValueChange = {},            readOnly = true,            leadingIcon = {                Icon(imageVector = Icons.Default.Schedule, contentDescription = null)            },            trailingIcon = {                ExposedDropdownMenuDefaults.TrailingIcon(expanded = isExpanded)            },            colors = ExposedDropdownMenuDefaults.textFieldColors(),            placeholder = { Text(text = "Тип замера") },            label = { Text(text = "Тип замера") },            modifier = Modifier.menuAnchor()        )        ExposedDropdownMenu(            expanded = isExpanded,            onDismissRequest = { isExpanded = false }        ) {            DropdownMenuItem(text = { Text(text = "Не указан") }, onClick = {                onMeasureTypeChange(GlucoseLevel.MeasureType.UNSPECIFIED)                isExpanded = false            })            DropdownMenuItem(text = { Text(text = "После еды") }, onClick = {                onMeasureTypeChange(GlucoseLevel.MeasureType.AFTER_MEAL)                isExpanded = false            })            DropdownMenuItem(text = { Text(text = "До еды") }, onClick = {                onMeasureTypeChange(GlucoseLevel.MeasureType.BEFORE_MEAL)                isExpanded = false            })        }    }}@OptIn(ExperimentalMaterial3Api::class)@Composableprivate fun DateTimePicker(    onDateChange: (Long?) -> Unit,    onTimeChange: (hour: Int, minute: Int) -> Unit) {    val now = LocalDateTime.now()    var showDatePicker by remember {        mutableStateOf(false)    }    var date by remember {        mutableStateOf(now.asDate())    }    var showTimePicker by remember {        mutableStateOf(false)    }    var time by remember {        mutableStateOf(now.asTime())    }    Row(        Modifier.width(280.dp),        horizontalArrangement = Arrangement.SpaceBetween    ) {        OutlinedTextField(            modifier = Modifier                .width(135.dp)                .clickable {                    showDatePicker = true                },            value = date,            onValueChange = {},            label = { Text(text = "Дата") },            readOnly = true,            enabled = false,            colors = OutlinedTextFieldDefaults.colors(                disabledTextColor = MaterialTheme.colorScheme.onSurface,                disabledBorderColor = MaterialTheme.colorScheme.outline,                disabledLabelColor = MaterialTheme.colorScheme.onSurfaceVariant            )        )        OutlinedTextField(            modifier = Modifier                .width(135.dp)                .clickable {                    showTimePicker = true                },            value = time,            onValueChange = {},            label = { Text(text = "Время") },            readOnly = true,            enabled = false,            colors = OutlinedTextFieldDefaults.colors(                disabledTextColor = MaterialTheme.colorScheme.onSurface,                disabledBorderColor = MaterialTheme.colorScheme.outline,                disabledLabelColor = MaterialTheme.colorScheme.onSurfaceVariant            )        )    }    val datePickerState = rememberDatePickerState(        null,        null,        IntRange(1000, 3000),        DisplayMode.Picker    )    if (showDatePicker) {        val confirm = {            date = datePickerState                .selectedDateMillis                ?.toLocalDateTime()                ?.asDate() ?: date            onDateChange(datePickerState.selectedDateMillis)            showDatePicker = false        }        DatePickerDialog(            onDismissRequest = confirm,            confirmButton = {                TextButton(onClick = confirm) {                    Text(text = "Выбрать")                }            },            colors = DatePickerDefaults.colors(                containerColor = MaterialTheme.colorScheme.surface            ),            tonalElevation = 0.dp        ) {            DatePicker(                state = datePickerState,                title = null,                headline = null,                showModeToggle = false            )        }    }    val timePickerState = rememberTimePickerState(        now.hour,        now.minute    )    if (showTimePicker) {        AlertDialog(            modifier = Modifier                .clip(RoundedCornerShape(35.dp))                .background(MaterialTheme.colorScheme.surface)                .padding(20.dp),            onDismissRequest = {                time = "%s:%s".format(                    if (timePickerState.hour < 10) "0${timePickerState.hour}"                    else timePickerState.hour.toString(),                    if (timePickerState.minute < 10) "0${timePickerState.minute}"                    else timePickerState.minute.toString(),                )                onTimeChange(timePickerState.hour, timePickerState.minute)                showTimePicker = false            }) {            TimePicker(                state = timePickerState,                colors = TimePickerDefaults.colors(                    clockDialColor = MaterialTheme.colorScheme.onPrimary,                )            )        }    }}private fun LocalDateTime.asDate(): String =    this.format(DateTimeFormatter.ofPattern("yyyy-MM-dd"))private fun LocalDateTime.asTime(): String =    this.format(DateTimeFormatter.ofPattern("HH:mm"))private data class AddGlucoseViewModelState(    val glucoseLevel: String = "",    val measureType: GlucoseLevel.MeasureType = GlucoseLevel        .MeasureType        .UNSPECIFIED,    val error: String = "",    val date: Long = LocalDate        .now()        .atTime(0, 0)        .atZone(ZoneId.systemDefault())        .toInstant()        .toEpochMilli(),    val hour: Int = LocalDateTime.now().atZone(ZoneId.systemDefault()).hour,    val minute: Int = LocalDateTime.now().atZone(ZoneId.systemDefault()).minute) {    val datetime: Long        get() {            return date +                    hour * 3_600_000 +                    minute * 60_000        }}private class AddGlucoseViewModel(    private val handler: AddGlucoseLevel.Handler,    initial: AddGlucoseViewModelState = AddGlucoseViewModelState("")) : ViewModel() {    private val _state = MutableStateFlow(initial)    val state = _state.asStateFlow()    fun changeGlucoseLevel(level: String) {        if (level.isFloatGraterThenZero() || level.isEmpty()) {            _state.value = _state.value.copy(                glucoseLevel = level            )        }    }    private fun String.isFloatGraterThenZero(): Boolean = this.run {        toFloatOrNull() !== null && toFloat() > 0F    }    fun changeMeasureType(measureType: GlucoseLevel.MeasureType) {        _state.value = _state.value.copy(            measureType = measureType        )    }    fun changeDate(date: Long?) {        if (date == null) {            return        }        _state.value = _state.value.copy(            date = date        )    }    fun changeTime(hour: Int, minute: Int) {        _state.value = _state.value.copy(            hour = hour,            minute = minute        )    }    fun addLevel(): Boolean {        val level = _state.value.glucoseLevel        if (level.isEmpty()) {            error("Заполните все поля!")            return false        }        return try {            saveLevel()            true        } catch (e: Throwable) {            error("Упс, что-то пошло не так!:(")            Log.e(null, e.toString())            false        }    }    private fun saveLevel() {        val level = _state.value.glucoseLevel.toFloat()        val type = _state.value.measureType        val datetime = _state.value.datetime.toLocalDateTime()        handler.handle(            AddGlucoseLevel.Command(                level,                type,                datetime            )        )    }    fun flushError() {        error("")    }    private fun error(msg: String) {        _state.value = _state.value.copy(            error = msg        )    }    companion object {        val Factory = object : ViewModelProvider.Factory {            @Suppress("UNCHECKED_CAST")            override fun <T : ViewModel> create(modelClass: Class<T>): T {                return AddGlucoseViewModel(                    ServiceLocator.addGlucoseLevelHandler()                ) as T            }        }    }}private fun Long.toLocalDateTime(): LocalDateTime {    return Instant.ofEpochMilli(this)        .atZone(ZoneId.systemDefault())        .toLocalDateTime()}@Preview@Composableprivate fun ContentPreview() {    Content(        AddGlucoseViewModel(            AddGlucoseLevel.Handler(                StubGlucoseLevelRepository()            )        )    )}