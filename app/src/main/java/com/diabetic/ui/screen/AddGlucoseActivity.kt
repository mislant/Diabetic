package com.diabetic.ui.screenimport android.content.Intentimport android.os.Bundleimport android.util.Logimport android.widget.Toastimport androidx.activity.ComponentActivityimport androidx.activity.compose.setContentimport androidx.activity.enableEdgeToEdgeimport androidx.compose.foundation.layout.Arrangementimport androidx.compose.foundation.layout.Columnimport androidx.compose.foundation.layout.Spacerimport androidx.compose.foundation.layout.fillMaxSizeimport androidx.compose.foundation.layout.paddingimport androidx.compose.foundation.layout.sizeimport androidx.compose.foundation.text.KeyboardOptionsimport androidx.compose.material.icons.Iconsimport androidx.compose.material.icons.filled.Bloodtypeimport androidx.compose.material.icons.filled.Scheduleimport androidx.compose.material3.DropdownMenuItemimport androidx.compose.material3.ExperimentalMaterial3Apiimport androidx.compose.material3.ExposedDropdownMenuBoximport androidx.compose.material3.ExposedDropdownMenuDefaultsimport androidx.compose.material3.FilledTonalButtonimport androidx.compose.material3.Iconimport androidx.compose.material3.OutlinedTextFieldimport androidx.compose.material3.Textimport androidx.compose.runtime.Composableimport androidx.compose.runtime.collectAsStateimport androidx.compose.runtime.getValueimport androidx.compose.runtime.mutableStateOfimport androidx.compose.runtime.rememberimport androidx.compose.runtime.setValueimport androidx.compose.ui.Alignmentimport androidx.compose.ui.Modifierimport androidx.compose.ui.platform.LocalContextimport androidx.compose.ui.text.input.KeyboardTypeimport androidx.compose.ui.tooling.preview.Previewimport androidx.compose.ui.unit.dpimport androidx.lifecycle.ViewModelimport androidx.lifecycle.ViewModelProviderimport androidx.lifecycle.viewmodel.compose.viewModelimport com.diabetic.application.command.AddGlucoseLevelimport com.diabetic.domain.model.GlucoseLevelimport com.diabetic.domain.model.time.datetimeimport com.diabetic.infrastructure.persistent.stub.StubGlucoseLevelRepositoryimport com.diabetic.ui.ServiceLocatorimport com.diabetic.ui.screen.component.DateTimePickerimport com.diabetic.ui.screen.component.DiabeticLayoutimport com.diabetic.ui.theme.DiabeticMaterialThemeimport kotlinx.coroutines.flow.MutableStateFlowimport kotlinx.coroutines.flow.asStateFlowimport java.time.LocalDateimport java.time.LocalDateTimeimport java.time.ZoneIdclass AddGlucoseActivity : ComponentActivity() {    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        enableEdgeToEdge()        setContent {            val model = viewModel<AddGlucoseViewModel>(                factory = AddGlucoseViewModel.Factory            )            Content(model)        }    }}@Composableprivate fun Content(model: AddGlucoseViewModel) {    val state = model.state.collectAsState()    DiabeticMaterialTheme {        if (state.value.error.isNotEmpty()) {            Toast                .makeText(                    LocalContext.current,                    state.value.error,                    Toast.LENGTH_LONG                )                .show()            model.flushError()        }        DiabeticLayout { innerPadding ->            Column(                modifier = Modifier                    .padding(innerPadding)                    .fillMaxSize(),                verticalArrangement = Arrangement.Center,                horizontalAlignment = Alignment.CenterHorizontally            ) {                AddGlucoseLevelForm(                    state = state.value,                    onGlucoseLevelChange = model::changeGlucoseLevel,                    onMeasureTypeChange = model::changeMeasureType,                    onDateChange = model::changeDate,                    onTimeChange = model::changeTime,                    saveGlucoseLevel = model::addLevel                )            }        }    }}@Composableprivate fun AddGlucoseLevelForm(    state: AddGlucoseViewModelState,    onGlucoseLevelChange: (String) -> Unit,    onMeasureTypeChange: (GlucoseLevel.MeasureType) -> Unit,    onDateChange: (Long?) -> Unit,    onTimeChange: (hour: Int, minute: Int) -> Unit,    saveGlucoseLevel: () -> Boolean) {    OutlinedTextField(        value = state.glucoseLevel,        singleLine = true,        onValueChange = onGlucoseLevelChange,        leadingIcon = {            Icon(                imageVector = Icons.Default.Bloodtype,                contentDescription = null            )        },        keyboardOptions = KeyboardOptions.Default.copy(            keyboardType = KeyboardType.Decimal        ),        placeholder = { Text(text = "Уровень глюкозы") },        label = { Text(text = "Уровень глюкозы") },    )    Spacer(modifier = Modifier.size(20.dp))    MeasureTypeDropDown(        state = state,        onMeasureTypeChange = onMeasureTypeChange    )    Spacer(modifier = Modifier.size(20.dp))    DateTimePicker(onDateChange, onTimeChange)    Spacer(modifier = Modifier.size(20.dp))    val ctx = LocalContext.current    FilledTonalButton(onClick = {        saveGlucoseLevel().onSuccess {            Intent(ctx, MainActivity::class.java).also {                ctx.startActivity(it)            }        }    }) {        Text(text = "Добавить")    }}private fun Boolean.onSuccess(block: () -> Unit) {    if (this) {        block()    }}@OptIn(ExperimentalMaterial3Api::class)@Composableprivate fun MeasureTypeDropDown(    state: AddGlucoseViewModelState,    onMeasureTypeChange: (GlucoseLevel.MeasureType) -> Unit) {    var isExpanded by remember {        mutableStateOf(false)    }    ExposedDropdownMenuBox(        expanded = isExpanded,        onExpandedChange = { isExpanded = it }    ) {        OutlinedTextField(            value = when (state.measureType) {                GlucoseLevel.MeasureType.AFTER_MEAL -> "После еды"                GlucoseLevel.MeasureType.BEFORE_MEAL -> "До еды"                GlucoseLevel.MeasureType.UNSPECIFIED -> "Не указан"            },            onValueChange = {},            readOnly = true,            leadingIcon = {                Icon(imageVector = Icons.Default.Schedule, contentDescription = null)            },            trailingIcon = {                ExposedDropdownMenuDefaults.TrailingIcon(expanded = isExpanded)            },            colors = ExposedDropdownMenuDefaults.textFieldColors(),            placeholder = { Text(text = "Тип замера") },            label = { Text(text = "Тип замера") },            modifier = Modifier.menuAnchor()        )        ExposedDropdownMenu(            expanded = isExpanded,            onDismissRequest = { isExpanded = false }        ) {            DropdownMenuItem(text = { Text(text = "Не указан") }, onClick = {                onMeasureTypeChange(GlucoseLevel.MeasureType.UNSPECIFIED)                isExpanded = false            })            DropdownMenuItem(text = { Text(text = "После еды") }, onClick = {                onMeasureTypeChange(GlucoseLevel.MeasureType.AFTER_MEAL)                isExpanded = false            })            DropdownMenuItem(text = { Text(text = "До еды") }, onClick = {                onMeasureTypeChange(GlucoseLevel.MeasureType.BEFORE_MEAL)                isExpanded = false            })        }    }}private data class AddGlucoseViewModelState(    val glucoseLevel: String = "",    val measureType: GlucoseLevel.MeasureType = GlucoseLevel        .MeasureType        .UNSPECIFIED,    val error: String = "",    val date: Long = LocalDate        .now()        .atTime(0, 0)        .atZone(ZoneId.systemDefault())        .toInstant()        .toEpochMilli(),    val hour: Int = LocalDateTime.now().atZone(ZoneId.systemDefault()).hour,    val minute: Int = LocalDateTime.now().atZone(ZoneId.systemDefault()).minute) {    val datetime: Long        get() {            return date +                    hour * 3_600_000 +                    minute * 60_000        }}private class AddGlucoseViewModel(    private val handler: AddGlucoseLevel.Handler,    initial: AddGlucoseViewModelState = AddGlucoseViewModelState("")) : ViewModel() {    private val _state = MutableStateFlow(initial)    val state = _state.asStateFlow()    fun changeGlucoseLevel(level: String) {        if (level.isFloatGraterThenZero() || level.isEmpty()) {            _state.value = _state.value.copy(                glucoseLevel = level            )        }    }    private fun String.isFloatGraterThenZero(): Boolean = this.run {        toFloatOrNull() !== null && toFloat() > 0F    }    fun changeMeasureType(measureType: GlucoseLevel.MeasureType) {        _state.value = _state.value.copy(            measureType = measureType        )    }    fun changeDate(date: Long?) {        if (date == null) {            return        }        _state.value = _state.value.copy(            date = date        )    }    fun changeTime(hour: Int, minute: Int) {        _state.value = _state.value.copy(            hour = hour,            minute = minute        )    }    fun addLevel(): Boolean {        val level = _state.value.glucoseLevel        if (level.isEmpty()) {            error("Заполните все поля!")            return false        }        return try {            saveLevel()            true        } catch (e: Throwable) {            error("Упс, что-то пошло не так!:(")            Log.e(null, e.toString())            false        }    }    private fun saveLevel() {        val level = _state.value.glucoseLevel.toFloat()        val type = _state.value.measureType        val datetime = _state.value.datetime.datetime        handler.handle(            AddGlucoseLevel.Command(                level,                type,                datetime            )        )    }    fun flushError() {        error("")    }    private fun error(msg: String) {        _state.value = _state.value.copy(            error = msg        )    }    companion object {        val Factory = object : ViewModelProvider.Factory {            @Suppress("UNCHECKED_CAST")            override fun <T : ViewModel> create(modelClass: Class<T>): T {                return AddGlucoseViewModel(                    ServiceLocator.addGlucoseLevelHandler()                ) as T            }        }    }}@Preview@Composableprivate fun ContentPreview() {    Content(        AddGlucoseViewModel(            AddGlucoseLevel.Handler(                StubGlucoseLevelRepository()            )        )    )}